-- =========================================
-- PhotoSIFT – Implementation-Level Schema
-- PostgreSQL 13+ recommended
-- =========================================

-- Safety first (run in a fresh DB or wrap in a transaction)
-- BEGIN;

-- ---------- Extensions you might want ----------
-- For more powerful JSON/GiST/GIN queries (optional)
-- CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- CREATE EXTENSION IF NOT EXISTS btree_gin;

-- ---------- Users ----------
CREATE TABLE IF NOT EXISTS users (
    user_id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name              TEXT NOT NULL,
    preferences       JSONB DEFAULT '{}'::jsonb,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ---------- Collections ----------
CREATE TABLE IF NOT EXISTS collections (
    collection_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id           BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    name              TEXT NOT NULL,
    date_created      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_collections_user_id ON collections(user_id);

-- ---------- Photos ----------
-- Note: UML shows Collection ||--o{ Photo, i.e., a photo may optionally belong to a collection.
-- If you want to enforce that every photo MUST belong to a collection, set collection_id NOT NULL.
CREATE TABLE IF NOT EXISTS photos (
    photo_id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    collection_id     BIGINT REFERENCES collections(collection_id) ON DELETE SET NULL,
    file_path         TEXT NOT NULL,                              -- absolute or project-relative path
    date_added        TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_photos_collection_id ON photos(collection_id);
CREATE UNIQUE INDEX uq_photos_file_path ON photos(file_path);

-- ---------- Thumbnails ----------
-- UML shows Photo ||--|| Thumbnail (1:1). We enforce "at most one thumbnail per photo"
-- via UNIQUE(photo_id). Ensuring "every photo has a thumbnail" typically handled in app logic or trigger.
CREATE TABLE IF NOT EXISTS thumbnails (
    thumbnail_id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    photo_id          BIGINT NOT NULL UNIQUE REFERENCES photos(photo_id) ON DELETE CASCADE,
    image_path        TEXT NOT NULL
);

CREATE UNIQUE INDEX uq_thumbnails_image_path ON thumbnails(image_path);

-- ---------- EXIF Data ----------
-- UML shows Photo ||--|| ExifData (1:1) and ExifData -> Thumbnail (FK).
-- We model strict 1:1 with PRIMARY KEY(photo_id) referencing photos(photo_id).
CREATE TABLE IF NOT EXISTS exif_data (
    exif_id           BIGINT GENERATED BY DEFAULT AS IDENTITY UNIQUE,  -- optional surrogate key
    photo_id          BIGINT PRIMARY KEY REFERENCES photos(photo_id) ON DELETE CASCADE,
    thumbnail_id      BIGINT UNIQUE REFERENCES thumbnails(thumbnail_id) ON DELETE SET NULL,

    make              TEXT,
    model             TEXT,
    lens_model        TEXT,
    focal_length_mm   NUMERIC(6,2),             -- e.g., 35.00
    exposure_time     TEXT,                      -- store as string like '1/200'
    f_number          NUMERIC(4,2),              -- e.g., 2.80
    iso_speed         INTEGER,
    datetime_original TIMESTAMPTZ,
    gps_latitude      DOUBLE PRECISION,
    gps_longitude     DOUBLE PRECISION
);

-- Useful composite index if you’ll query by GPS bounding boxes frequently:
-- CREATE INDEX idx_exif_data_gps ON exif_data (gps_latitude, gps_longitude);

-- ---------- Scores ----------
-- UML: Photo ||--o{ Score (many scores per photo). Enforce one row per metric via UNIQUE.
CREATE TABLE IF NOT EXISTS scores (
    score_id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    photo_id          BIGINT NOT NULL REFERENCES photos(photo_id) ON DELETE CASCADE,
    metric_name       TEXT NOT NULL,
    value             DOUBLE PRECISION NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT uq_scores_photo_metric UNIQUE (photo_id, metric_name)
);

CREATE INDEX idx_scores_photo_id ON scores(photo_id);

-- ---------- Faces ----------
-- UML: Photo ||--o{ Face. bounding_box stored as JSONB: {x, y, w, h} (0..1 normalized or pixels).
CREATE TABLE IF NOT EXISTS faces (
    face_id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    photo_id          BIGINT NOT NULL REFERENCES photos(photo_id) ON DELETE CASCADE,
    bounding_box      JSONB NOT NULL,           -- e.g., {"x":0.12,"y":0.33,"w":0.25,"h":0.30}
    attributes        JSONB DEFAULT '{}'::jsonb -- optional (age, gender estimates, landmarks, etc.)
);

CREATE INDEX idx_faces_photo_id ON faces(photo_id);
-- Optional JSONB GIN index for querying faces/attributes:
-- CREATE INDEX idx_faces_bbox_gin ON faces USING GIN (bounding_box);

-- ---------- Image Comments ----------
-- UML: Photo ||--o{ ImageComment
CREATE TABLE IF NOT EXISTS image_comments (
    image_comment_id  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    photo_id          BIGINT NOT NULL REFERENCES photos(photo_id) ON DELETE CASCADE,
    content           TEXT NOT NULL,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by        BIGINT REFERENCES users(user_id) ON DELETE SET NULL
);

CREATE INDEX idx_image_comments_photo_id ON image_comments(photo_id);

-- ---------- Collection Comments ----------
-- UML: Collection ||--o{ CollectionComment
CREATE TABLE IF NOT EXISTS collection_comments (
    collection_comment_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    collection_id         BIGINT NOT NULL REFERENCES collections(collection_id) ON DELETE CASCADE,
    content               TEXT NOT NULL,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by            BIGINT REFERENCES users(user_id) ON DELETE SET NULL
);

CREATE INDEX idx_collection_comments_collection_id ON collection_comments(collection_id);

-- ---------- Near-Duplicate Groups ----------
CREATE TABLE IF NOT EXISTS near_duplicate_groups (
    group_id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW()
    -- add fields like heuristic_name, threshold, etc. if needed
);

-- ---------- Near-Duplicate ↔ Photos (bridge) ----------
-- UML: NearDuplicateGroup ||--o{ NearDuplicatePhoto and Photo ||--o{ NearDuplicatePhoto
-- Many-to-many: a photo can appear in multiple groups; a group has many photos.
CREATE TABLE IF NOT EXISTS near_duplicate_photos (
    group_id          BIGINT NOT NULL REFERENCES near_duplicate_groups(group_id) ON DELETE CASCADE,
    photo_id          BIGINT NOT NULL REFERENCES photos(photo_id) ON DELETE CASCADE,
    similarity_score  DOUBLE PRECISION,  -- optional: score within the group
    PRIMARY KEY (group_id, photo_id)
);

CREATE INDEX idx_ndp_photo_id ON near_duplicate_photos(photo_id);

-- ---------- Helpful views (optional) ----------
-- CREATE VIEW v_photo_with_exif AS
-- SELECT p.photo_id, p.file_path, e.*
-- FROM photos p
-- LEFT JOIN exif_data e ON e.photo_id = p.photo_id;

-- COMMIT;
